using UnityEngine;

// Modified from the Unity wiki:

// https://wiki.unity3d.com/index.php/Singleton
// This version uses ScriptableObject as a base.
// This allows for hot reloading after a recompile.
// Inspired by 2016 Unite talk by Unity: https://www.youtube.com/watch?v=6vmRwLYWNRo by Richard Fine

namespace Radial.Singleton
{
	/// <summary>
	/// Inherit from this base class to create a singleton. eg:
	/// public class MyClassName : ScriptableSingleton<MyClassName> {}
	/// 
	/// Be aware this will not prevent a non singleton constructor, such as:
	/// MyClassName badActor = new MyClassName();
	/// To prevent that, you can override the constructor in your class with this:
	/// protected MyClassName() { }
	///
	/// Note that this needs to be loaded into memory in one of four ways;
	/// 
	/// 1) Project Settings > Player > Other > Preload Assets (* only works in compiled versions, not in editor!)
	/// 2) Reference the ScriptableObject in your scene via a public reference
	/// 3) Manually use a Resources.Load call to load the asset specifically
	///
	/// Those are all good for most development practices. The dangerous/tricksy one:
	/// 
	/// 4) You can load this asset into memory, in the editor only, by simply looking at
	/// the asset in the inspector. When you hit play, if the garbage collector hasn't come
	/// around yet, it'll still be in memory. This will probably give you weird results you
	/// aren't expecting unless you're making a fancy editor tool with this.
	/// </summary>
	public class ScriptableSingleton<T> : ScriptableObject where T : ScriptableObject
	{
		private static bool m_ShuttingDown = false;
		private static object m_Lock = new object();
		private static T m_Instance;

		public static T instance
		{
			get
			{
				// Check to see if we're about to be destroyed.
				if (m_ShuttingDown)
				{
					Debug.LogWarning($"[{nameof(ScriptableSingleton<T>)}] Instance '{typeof(T)}' already destroyed. Returning null.");
					return null;
				}

				// Wait for threadsafe lock.
				lock (m_Lock)
				{
					if (m_Instance == null)
					{
						// Search for existing instance in the scene.
						var candidates = Resources.FindObjectsOfTypeAll<T>();
						//var candidates = Resources.LoadAll<T>("");
						if (candidates.Length > 0)
						{
							if (candidates.Length > 1)
							{
								// Does this crop up if you look at things in the editor? If so, we might want to select the one in the scene instead, if we can.
								Debug.LogError($"Found multiple instances of type {typeof(T)} loaded into memory. We'll use the first one, but this might produce unexpected behaviours. Make sure you don't have multiple references in the scene.");
							}
							m_Instance = candidates[0];
						}

						// Create new instance if one doesn't already exist.
						if (m_Instance == null)
						{
							//Debug.LogWarning("Generating new instance; one didn't exist.");
							m_Instance = CreateInstance<T>();
							m_Instance.name = $"AutoGenerated {typeof(T)} Instance";
						}

						// Unload all except ours:
						foreach (var candidate in candidates)
						{
							if (candidate != m_Instance)
							{
								Resources.UnloadAsset(candidate);
							}
						}
					}
					return m_Instance;
				}
			}
		}

		private void OnDestroy()
		{
			m_ShuttingDown = true;
			m_Instance = null;	// This hopefully clears the reference that can be generated by the editor.
		}
	}
}